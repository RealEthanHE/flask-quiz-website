<!DOCTYPE html>
<html lang="zh-CN">
<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€‰æ‹©é¢˜åœ¨çº¿ç»ƒä¹ </title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        /* æ‚¨ä¹‹å‰æä¾›çš„CSSæ ·å¼å¯ä»¥æ”¾åœ¨ static/style.css æ–‡ä»¶ä¸­ */
        /* è¿™é‡Œå¯ä»¥ä¿ç•™ä¸€äº›é¡µé¢ç‰¹æœ‰çš„ã€æˆ–è€…æ‚¨å¸Œæœ›è¦†ç›–çš„æ ·å¼ */
    </style>
</head>
<body>    <div class="main-wrapper">
        <div class="user-info-bar">
            <div>
                {% if username %}
                    <span>æ¬¢è¿æ‚¨, <strong>{{ username }}</strong>! ğŸ¯</span>
                {% else %}
                    <span>æ¬¢è¿, è®¿å®¢! è¯·å…ˆ<a href="{{ url_for('login_page') }}" style="color: #60a5fa; text-decoration: underline;">ç™»å½•</a> ğŸ”</span>
                {% endif %}
            </div>
            <div>
                {% if username %}
                    <button id="logoutBtnGlobal" class="btn-danger">é€€å‡ºç™»å½•</button> 
                {% endif %}
            </div>
        </div>
        
        <div class="container-box">
            <h1>ğŸš€ æ™ºèƒ½é€‰æ‹©é¢˜ç»ƒä¹ ç³»ç»Ÿ</h1>
            <p class="subtitle">åŸºäºAIçš„ä¸ªæ€§åŒ–å­¦ä¹ ä½“éªŒ</p>
              <!-- å¯¼èˆªæ  -->
            <div class="navigation-bar">
                <div style="display: flex; gap: 15px; align-items: center;">
                    <a href="{{ url_for('chapter_practice') }}" class="btn btn-outline">
                        ğŸ“– ç« èŠ‚ç»ƒä¹ 
                    </a>
                    <a href="{{ url_for('wrong_answers_page') }}" class="btn btn-outline">
                        ğŸ“š æˆ‘çš„é”™é¢˜æœ¬
                    </a>
                    {% if mode == 'retry' %}
                    <span class="mode-indicator mode-retry">ğŸ”„ é”™é¢˜é‡åšæ¨¡å¼</span>
                    {% else %}
                    <span class="mode-indicator mode-normal">ğŸ“ æ··åˆç»ƒä¹ æ¨¡å¼</span>
                    {% endif %}
                </div>
                <div>
                    {% if mode == 'retry' %}
                    <a href="{{ url_for('quiz_page_actual') }}" class="btn btn-secondary">
                        â† è¿”å›æ­£å¸¸ç»ƒä¹ 
                    </a>
                    {% endif %}
                </div>
            </div>
        
        <div class="question-header">
            <span id="questionSource" class="question-source">æ¥æº: --</span>
            <span id="setQuestionProgress">é¢˜ç›®: 0/0</span>
        </div>

        <div id="questionText" class="question-text">é¢˜ç›®åŠ è½½ä¸­...</div>
        <div id="optionsContainer" class="options"></div> 
        <div id="feedbackArea" class="feedback"></div>            <div class="button-container">
                <button id="submitBtn" class="btn btn-primary">âœ… æäº¤ç­”æ¡ˆ</button>
            </div>
            
            <div id="resultsArea" class="results-summary" style="display:none;">
                <h3>ğŸ“Š æœ¬ç»„ç­”é¢˜ç»“æœ</h3>
                <p id="scoreText"></p>
                <div id="incorrectReview"></div>
                <button id="nextSetBtn" class="btn btn-secondary" style="display:none; margin-top:15px;">
                    ğŸ¯ å¼€å§‹ä¸‹ä¸€ç»„ / æŸ¥çœ‹æ€»ç»“
                </button>
            </div>
        </div>

        <div id="overallProgress" class="progress-info">ğŸ“ˆ æ€»è¿›åº¦: 0/0</div>
    </div>

    <!-- Server data passed to client -->
    <script type="application/json" id="server-data">
        {{ all_questions_from_server | tojson }}
    </script>
    
    <script>
        // --- QUESTION_DATA ---
        const LOGOUT_API_URL = "{{ url_for('api_logout') }}";
        let QUESTION_DATA = [];

        function populateAllQuestions() {
            // Use data passed from the server
            const serverDataElement = document.getElementById('server-data');
            let serverData = [];
            
            if (serverDataElement && serverDataElement.textContent) {
                try {
                    serverData = JSON.parse(serverDataElement.textContent);
                } catch (e) {
                    console.error("Failed to parse server data:", e);
                    serverData = [];
                }
            }
            
            if (Array.isArray(serverData) && serverData.length > 0) {
                QUESTION_DATA = serverData;
            } else {
                console.warn("No questions received from server or data is invalid. Using fallback.");
                QUESTION_DATA = []; // Or keep a minimal fallback if desired
            }
            
            // Sort the questions (important if server doesn't guarantee order or for consistency)
            const typeToSortKey = (qType) => {
                if (qType === "single") return 1;
                if (qType === "multiple") return 2;
                if (qType === "judgment_as_single") return 3;
                return 4; // Default for any other types
            };

            QUESTION_DATA.sort((a, b) => {
                if (a.doc_order !== b.doc_order) return a.doc_order - b.doc_order;
                if (typeToSortKey(a.type) !== typeToSortKey(b.type)) return typeToSortKey(a.type) - typeToSortKey(b.type);
                return a.q_num_in_doc - b.q_num_in_doc;
            });
            
            console.log(`Total questions populated: ${QUESTION_DATA.length}`);
            if (QUESTION_DATA.length === 0) {
                // Fallback if no questions are loaded
                QUESTION_DATA.push({
                    id: "dummy_s1", 
                    type: "single", 
                    source_doc: "N/A", 
                    doc_order: 0, 
                    q_num_in_doc: 1, 
                    question: "é¢˜åº“ä¸ºç©ºæˆ–åŠ è½½å¤±è´¥ï¼è¯·æ£€æŸ¥åå°æ•°æ®ã€‚", 
                    options: {"A": "å¥½çš„"}, 
                    answer: "A"
                });
            }
        }

        let currentMasterIndex = 0;
        const questionsPerSet = 20; // æ‚¨å¯ä»¥è°ƒæ•´æ¯ç»„çš„é¢˜ç›®æ•°é‡
        let currentSetQuestions = [];
        let currentQuestionInSetIndex = 0;
        let scoreForCurrentSet = 0;
        let incorrectlyAnsweredInSet = [];

        const questionTextEl = document.getElementById('questionText');
        const optionsContainerEl = document.getElementById('optionsContainer');
        const submitBtnEl = document.getElementById('submitBtn');
        const feedbackAreaEl = document.getElementById('feedbackArea');
        const resultsAreaEl = document.getElementById('resultsArea');
        const scoreTextEl = document.getElementById('scoreText');
        const incorrectReviewEl = document.getElementById('incorrectReview');
        const nextSetBtnEl = document.getElementById('nextSetBtn');
        const questionSourceEl = document.getElementById('questionSource');
        const setQuestionProgressEl = document.getElementById('setQuestionProgress');
        const overallProgressEl = document.getElementById('overallProgress');
        const logoutButton = document.getElementById('logoutBtnGlobal'); // è·å–å”¯ä¸€çš„ç™»å‡ºæŒ‰é’®

        function startNewSet() {
            scoreForCurrentSet = 0;
            currentQuestionInSetIndex = 0;
            incorrectlyAnsweredInSet = [];
            feedbackAreaEl.textContent = '';
            feedbackAreaEl.className = 'feedback';
            resultsAreaEl.style.display = 'none';
            submitBtnEl.style.display = 'inline-block';
            submitBtnEl.disabled = false; // ç¡®ä¿æäº¤æŒ‰é’®å¯ç”¨
            nextSetBtnEl.style.display = 'none';
            optionsContainerEl.style.display = 'block';

            const startIdx = currentMasterIndex;
            const endIdx = Math.min(currentMasterIndex + questionsPerSet, QUESTION_DATA.length);

            if (startIdx >= QUESTION_DATA.length) {
                questionTextEl.textContent = "æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰é¢˜ç›®ï¼";
                optionsContainerEl.innerHTML = '';
                submitBtnEl.style.display = 'none';
                nextSetBtnEl.style.display = 'none';
                questionSourceEl.textContent = "æ¥æº: --";
                setQuestionProgressEl.textContent = "é¢˜ç›®: --";
                updateOverallProgress();
                return;
            }

            currentSetQuestions = QUESTION_DATA.slice(startIdx, endIdx);
            
            if (currentSetQuestions.length > 0) {
                displayQuestion();
            } else {
                 questionTextEl.textContent = "æ²¡æœ‰æ›´å¤šé¢˜ç›®äº†æˆ–é¢˜åº“æ•°æ®ä¸è¶³ã€‚";
                 submitBtnEl.style.display = 'none'; // å¦‚æœæ²¡æœ‰é¢˜ç›®ï¼Œä¹Ÿéšè—æäº¤æŒ‰é’®
            }
            updateOverallProgress();
        }

        function displayQuestion() {
            submitBtnEl.disabled = false;
            feedbackAreaEl.textContent = '';
            feedbackAreaEl.className = 'feedback';

            const qData = currentSetQuestions[currentQuestionInSetIndex];
            questionTextEl.textContent = qData.question;
            questionSourceEl.textContent = `æ¥æº: ${qData.source_doc} (é¢˜å· ${qData.q_num_in_doc})`;
            setQuestionProgressEl.textContent = `é¢˜ç›®: ${currentQuestionInSetIndex + 1}/${currentSetQuestions.length}`;
            optionsContainerEl.innerHTML = ''; 

            const sortedOptionKeys = Object.keys(qData.options).sort();

            if (qData.type === "single" || qData.type === "judgment_as_single") {
                sortedOptionKeys.forEach(key => {
                    const optionDiv = document.createElement('div');
                    const radio = document.createElement('input');
                    radio.type = 'radio';
                    radio.name = 'option';
                    radio.value = key;
                    radio.id = 'option' + key + currentQuestionInSetIndex; 
                    
                    const label = document.createElement('label');
                    label.htmlFor = 'option' + key + currentQuestionInSetIndex;
                    label.textContent = ` ${key}. ${qData.options[key]}`;
                    
                    optionDiv.appendChild(radio);
                    optionDiv.appendChild(label);
                    optionDiv.addEventListener('click', () => radio.click());
                    optionsContainerEl.appendChild(optionDiv);
                });
            } else if (qData.type === "multiple") {
                sortedOptionKeys.forEach(key => {
                    const optionDiv = document.createElement('div');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = 'option'; 
                    checkbox.value = key;
                    checkbox.id = 'option' + key + currentQuestionInSetIndex;

                    const label = document.createElement('label');
                    label.htmlFor = 'option' + key + currentQuestionInSetIndex;
                    label.textContent = ` ${key}. ${qData.options[key]}`;

                    optionDiv.appendChild(checkbox);
                    optionDiv.appendChild(label);
                    optionDiv.addEventListener('click', (e) => {
                        if(e.target !== checkbox) checkbox.checked = !checkbox.checked;
                    });
                    optionsContainerEl.appendChild(optionDiv);
                });
            }
            updateOverallProgress();
        }        submitBtnEl.addEventListener('click', async function() {
            if (currentQuestionInSetIndex >= currentSetQuestions.length) return;

            const qData = currentSetQuestions[currentQuestionInSetIndex];
            let userAnswer = "";
            let isAnswerSelected = false;

            if (qData.type === "single" || qData.type === "judgment_as_single") {
                const selectedRadio = optionsContainerEl.querySelector('input[name="option"]:checked');
                if (selectedRadio) {
                    userAnswer = selectedRadio.value;
                    isAnswerSelected = true;
                }
            } else if (qData.type === "multiple") {
                const selectedCheckboxes = Array.from(optionsContainerEl.querySelectorAll('input[name="option"]:checked'))
                                               .map(cb => cb.value)
                                               .sort(); 
                if (selectedCheckboxes.length > 0) {
                    userAnswer = selectedCheckboxes.join('');
                    isAnswerSelected = true;
                }
            }

            if (!isAnswerSelected) {
                alert("è¯·é€‰æ‹©ä¸€ä¸ªç­”æ¡ˆï¼");
                return;
            }

            const correctAnswer = qData.answer.split('').sort().join(''); 
            const isCorrect = userAnswer === correctAnswer;
            
            // æäº¤ç­”æ¡ˆåˆ°åç«¯
            try {
                const response = await fetch("{{ url_for('submit_answer') }}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        question_id: qData.id,
                        user_answer: userAnswer,
                        correct_answer: qData.answer, // ä½¿ç”¨åŸå§‹ç­”æ¡ˆï¼Œä¸æ’åº
                        question_data: qData
                    })
                });
                
                if (!response.ok) {
                    console.error('æäº¤ç­”æ¡ˆå¤±è´¥:', response.status);
                }
            } catch (error) {
                console.error('æäº¤ç­”æ¡ˆå‡ºé”™:', error);
            }
            
            if (isCorrect) {
                scoreForCurrentSet++;
                feedbackAreaEl.textContent = "å›ç­”æ­£ç¡®ï¼";
                feedbackAreaEl.className = 'feedback correct';
            } else {
                feedbackAreaEl.textContent = `å›ç­”é”™è¯¯ã€‚æ­£ç¡®ç­”æ¡ˆ: ${qData.answer}`;
                feedbackAreaEl.className = 'feedback incorrect';
                incorrectlyAnsweredInSet.push({
                    questionData: qData,
                    userAnswer: userAnswer,
                    correctAnswer: qData.answer
                });
            }

            submitBtnEl.disabled = true;
            setTimeout(() => {
                currentQuestionInSetIndex++;
                if (currentQuestionInSetIndex < currentSetQuestions.length) {
                    displayQuestion();
                } else {
                    currentMasterIndex += currentSetQuestions.length; 
                    showSetResults();
                }
            }, 1500); 
        });
        
        if (nextSetBtnEl) { // ç¡®ä¿æŒ‰é’®å­˜åœ¨
            nextSetBtnEl.addEventListener('click', startNewSet);
        }

        function showSetResults() {
            questionTextEl.textContent = "æœ¬ç»„ç­”é¢˜ç»“æŸï¼";
            optionsContainerEl.style.display = 'none';
            submitBtnEl.style.display = 'none';
            feedbackAreaEl.textContent = '';
            feedbackAreaEl.className = 'feedback';

            resultsAreaEl.style.display = 'block';
            scoreTextEl.textContent = `ä½ çš„å¾—åˆ†: ${scoreForCurrentSet} / ${currentSetQuestions.length}`;
            
            incorrectReviewEl.innerHTML = ''; 
            if (incorrectlyAnsweredInSet.length > 0) {
                const reviewTitle = document.createElement('h4');
                reviewTitle.textContent = "é”™é¢˜å›é¡¾ä¸è§£æ:";
                incorrectReviewEl.appendChild(reviewTitle);

                incorrectlyAnsweredInSet.forEach(item => {
                    const p = document.createElement('p');
                    p.className = 'incorrect-answer-review';
                    p.innerHTML = `<strong>é¢˜ç›® (æº: ${item.questionData.source_doc}, é¢˜å· ${item.questionData.q_num_in_doc}):</strong> ${item.questionData.question}<br>
                                   ä½ çš„ç­”æ¡ˆ: ${item.userAnswer}, <strong>æ­£ç¡®ç­”æ¡ˆ: ${item.correctAnswer}</strong><br>
                                   <em>è§£æ: æ­£ç¡®ç­”æ¡ˆæ˜¯ ${item.correctAnswer}</em>`;
                    incorrectReviewEl.appendChild(p);
                });
            } else if (currentSetQuestions.length > 0) {
                 const p = document.createElement('p');
                 p.textContent = "å¤ªæ£’äº†ï¼Œæœ¬ç»„å…¨éƒ¨å›ç­”æ­£ç¡®ï¼";
                 incorrectReviewEl.appendChild(p);
            }
            
            if (currentMasterIndex < QUESTION_DATA.length) {
                if(nextSetBtnEl) {
                    nextSetBtnEl.textContent = "å¼€å§‹ä¸‹ä¸€ç»„";
                    nextSetBtnEl.style.display = 'inline-block';
                }
            } else {
                if(nextSetBtnEl) nextSetBtnEl.style.display = 'none'; 
                 const p = document.createElement('p');
                 p.innerHTML = "<strong>æ‰€æœ‰é¢˜ç›®å‡å·²å®Œæˆï¼</strong>";
                 if(incorrectReviewEl) incorrectReviewEl.appendChild(p); // ç¡®ä¿ incorrectReviewEl å­˜åœ¨
            }
            updateOverallProgress();
        }

        function updateOverallProgress() {
            const questionsDone = Math.min(currentMasterIndex, QUESTION_DATA.length);
            overallProgressEl.textContent = `æ€»é¢˜åº“è¿›åº¦: ${questionsDone}/${QUESTION_DATA.length}`;
        }        // ç™»å‡ºæŒ‰é’®é€»è¾‘
        if (logoutButton) { // ç¡®ä¿æŒ‰é’®å­˜åœ¨äºDOMä¸­
            logoutButton.addEventListener('click', async () => {
                try {
                    const response = await fetch(LOGOUT_API_URL, { 
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const result = await response.json();
                    if (response.ok && result.redirect_url) {
                        window.location.href = result.redirect_url;
                    } else {
                        alert(result.message || 'ç™»å‡ºå¤±è´¥');
                    }
                } catch (error) {
                    console.error('ç™»å‡ºè¯·æ±‚å‡ºé”™:', error);
                    alert('ç™»å‡ºè¯·æ±‚å‡ºé”™ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚');
                }
            });
        } else {
            // å¦‚æœç™»å‡ºæŒ‰é’®ä¸å­˜åœ¨ï¼ˆä¾‹å¦‚ç”¨æˆ·æœªç™»å½•æ—¶ï¼ŒJinja2æ¡ä»¶ä¸æ¸²æŸ“å®ƒï¼‰ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            // console.log("ç™»å‡ºæŒ‰é’®æœªæ‰¾åˆ° (å¯èƒ½ç”¨æˆ·æœªç™»å½•)");
        }

        // Initial load
        populateAllQuestions();
        if (QUESTION_DATA.length > 0 && (QUESTION_DATA[0].id !== "dummy_s1" || QUESTION_DATA.length > 1) ) {
            startNewSet();
        } else {
             questionTextEl.textContent = QUESTION_DATA.length > 0 ? QUESTION_DATA[0].question : "é”™è¯¯ï¼šé¢˜åº“ä¸ºç©ºæˆ–åŠ è½½å¤±è´¥ã€‚";
             optionsContainerEl.innerHTML = (QUESTION_DATA.length > 0 && QUESTION_DATA[0].id === "dummy_s1") ? "è¯·æ£€æŸ¥åå°æ•°æ®æºã€‚" : "";
             if(submitBtnEl) submitBtnEl.style.display = 'none';
             if(QUESTION_DATA.length === 0) console.error("QUESTION_DATA is empty after populateAllQuestions!");
        }
    </script>
</body>
</html>